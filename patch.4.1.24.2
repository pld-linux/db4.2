*** dbinc_auto/int_def.in	2002/09/03 17:27:19	1.70
--- dbinc_auto/int_def.in	2002/09/18 19:01:43
***************
*** 1172,1177 ****
--- 1172,1178 ----
  #define	__txn_force_abort __txn_force_abort@DB_VERSION_UNIQUE_NAME@
  #define	__txn_preclose __txn_preclose@DB_VERSION_UNIQUE_NAME@
  #define	__txn_reset __txn_reset@DB_VERSION_UNIQUE_NAME@
+ #define	__txn_updateckp __txn_updateckp@DB_VERSION_UNIQUE_NAME@
  #define	__txn_regop_log __txn_regop_log@DB_VERSION_UNIQUE_NAME@
  #define	__txn_regop_getpgnos __txn_regop_getpgnos@DB_VERSION_UNIQUE_NAME@
  #define	__txn_regop_print __txn_regop_print@DB_VERSION_UNIQUE_NAME@
*** dbinc_auto/txn_ext.h	2002/09/03 17:27:20	1.32
--- dbinc_auto/txn_ext.h	2002/09/18 19:01:43
***************
*** 20,25 ****
--- 20,26 ----
  int __txn_force_abort __P((DB_ENV *, u_int8_t *));
  int __txn_preclose __P((DB_ENV *));
  int __txn_reset __P((DB_ENV *));
+ void __txn_updateckp __P((DB_ENV *, DB_LSN *));
  int __txn_regop_log __P((DB_ENV *, DB_TXN *, DB_LSN *, u_int32_t, u_int32_t, int32_t));
  int __txn_regop_getpgnos __P((DB_ENV *, DBT *, DB_LSN *, db_recops, void *));
  int __txn_regop_print __P((DB_ENV *, DBT *, DB_LSN *, db_recops, void *));
*** rep/rep_record.c	2002/09/11 19:39:11	1.111
--- rep/rep_record.c	2002/09/18 19:01:58
***************
*** 1198,1203 ****
--- 1198,1206 ----
  			 * replica get flushed now and again.
  			 */
  			ret = dbenv->log_flush(dbenv, &ckp_lsn);
+ 		/* Update the last_ckp in the txn region. */
+ 		if (ret == 0)
+ 			__txn_updateckp(dbenv, &rp->lsn);
  		break;
  	case DB___txn_regop:
  		if (!F_ISSET(dbenv, DB_ENV_REP_LOGSONLY))
*** txn/txn.c	2002/08/29 17:41:17	11.179
--- txn/txn.c	2002/09/18 19:02:05
***************
*** 1209,1226 ****
  			return (ret);
  		}
  
! 		/*
! 		 * We want to make sure last_ckp only moves forward;  since
! 		 * we drop locks above and in log_put, it's possible
! 		 * for two calls to __txn_ckp_log to finish in a different
! 		 * order from how they were called.
! 		 */
! 		R_LOCK(dbenv, &mgr->reginfo);
! 		if (log_compare(&region->last_ckp, &ckp_lsn) < 0) {
! 			region->last_ckp = ckp_lsn;
! 			(void)time(&region->time_ckp);
! 		}
! 		R_UNLOCK(dbenv, &mgr->reginfo);
  	}
  	return (0);
  }
--- 1209,1215 ----
  			return (ret);
  		}
  
! 		__txn_updateckp(dbenv, &ckp_lsn);
  	}
  	return (0);
  }
***************
*** 1403,1406 ****
--- 1392,1428 ----
  	DB_ASSERT(LOGGING_ON(dbenv));
  	return (__txn_recycle_log(dbenv,
  	    NULL, &scrap, 0, TXN_MINIMUM, TXN_MAXIMUM));
+ }
+ 
+ /*
+  * __txn_updateckp --
+  *	Update the last_ckp field in the transaction region.  This happens
+  * at the end of a normal checkpoint and also when a replication client
+  * receives a checkpoint record.
+  *
+  * PUBLIC: void __txn_updateckp __P((DB_ENV *, DB_LSN *));
+  */
+ void
+ __txn_updateckp(dbenv, lsnp)
+ 	DB_ENV *dbenv;
+ 	DB_LSN *lsnp;
+ {
+ 	DB_TXNMGR *mgr;
+ 	DB_TXNREGION *region;
+ 
+ 	mgr = dbenv->tx_handle;
+ 	region = mgr->reginfo.primary;
+ 
+ 	/*
+ 	 * We want to make sure last_ckp only moves forward;  since
+ 	 * we drop locks above and in log_put, it's possible
+ 	 * for two calls to __txn_ckp_log to finish in a different
+ 	 * order from how they were called.
+ 	 */
+ 	R_LOCK(dbenv, &mgr->reginfo);
+ 	if (log_compare(&region->last_ckp, lsnp) < 0) {
+ 		region->last_ckp = *lsnp;
+ 		(void)time(&region->time_ckp);
+ 	}
+ 	R_UNLOCK(dbenv, &mgr->reginfo);
  }
